--[[
    2048 plus based on the original version of 2048 and
    extend the rules with user defined functions

    implement the classic version first
        new elements will be generated after each move
        game ends when unmovable
    time trial
        new elements will be generated by every 0.5 seconds
        game ends when table filled up
]]

--[[
    2 = 2^1
    ...
    2048 = 2^11
]]

require('src/Depandencies')

function love.load()
    love.graphics.setBackgroundColor(BackGroundColor)

    -- for i = 0 , 13 do 
    --     genRam()
    -- end
--
    -- genRam(2,1,4)
    -- genRam(4,2,4)
    -- genRam(4,3,4)

    -- genRam(2,1,4)
    -- genRam(4,4,1)
    -- genRam(4,4,4)
    
    -- genRam(4,1,1 )
    -- genRam(4,1,2 )
    -- genRam(4,1,3 )
    -- genRam(4,1,4 )


    -- genRam(4,4,2 )
    -- genRam(4,3,3 )
    -- genRam(4,4,4 )
--

    -- for i = 1 , 4 do
    --     for j = 1 , 4 do
    --         genRam( _ , j , i)
    --     end
    -- end

    genRam()
    genRam()


    -- genRamTable()
end

function love.update(dt)
    -- control the timing of toggling states
    if state ~= 'non' then
        keyPressDelayCouter = keyPressDelayCouter + 1 *dt
        if keyPressDelayCouter > stateCD then
            keyPressDelayCouter = 0
            state = 'non'
            upBar = false
            downBar = false
            leftBar = false
            rightBar = false
            -- indexUpdate()
            -- genRam(2)
        end
    end

    if toLight then -- for game over page
        lightness = lightness + 4*dt
        if lightness >= 1 then
            lightness = 1
            toLight = false
        end
    end

    -- give dt to the box objects 
    for i , box in pairs(surfaceTable) do 
        box:update(dt)
    end
    -- give dt to the popup elements (inside the tempRender table)
    for i , box in pairs(tempRender) do
        box:update(dt)
    end

    
-- shift operation and index updates-------------------

    -- the summed boxes will render automatically when the elements in
    --  waiting list complete moving
    -- consider the close / delete conditions
    -- when user press dir arrow key, the tableComMoving flag toggles (turn to false)
   
    --
        -- 1. there exists some summed elements
            -- check the element in tempRender table complete rendered
                -- if complete then 
                    -- set surfaceTable elements as same as the tempSurfaceTable
                    -- delete all elements in the tempRender (stop render)
                    -- reset the tables (TempSurfaceTable)


        -- 2. there does not exist any summed elements
            -- check the elements in surfaceTable complete moving
                -- if complete then 
                    -- set surfaceTable elements as same as the tempSurfaceTable
                    -- reset the tables (TempSurfaceTable)
    --

   
    if not tableComMoving then
        if #tempWaitingList ~= 0 then
            if checkComRender() then
                for i = 1 , 4 do
                    for j = 1 , 4 do
                        -- surfaceTable[tostring(i) ..',' .. tostring(j)]:setNumXY( i, j, 1024)
                        surfaceTable[tostring(i) ..',' .. tostring(j)]:setNumXY( i, j, tempSurfaceTable[tostring(i) ..',' .. tostring(j)])
                        -- tempSurfaceTable[tostring(i) ..',' .. tostring(j)]
                    end
                end
                -- genRam(2)



                for i=1 , #tempRender do
                    table.remove( tempRender)
                    table.remove( tempWaitingList)
                end

                for i = 1 , 4 do
                    for j = 1 , 4 do
                        tempSurfaceTable[tostring(i) ..',' .. tostring(j)] = -1
                    end
                end

                longDisplay = true
                tableComMoving = true

                updateFreeSpace()

                genRam(2)
                -- keyPressDelayCouter = 20
            end
        else
            if checkComMoving() then
                for i = 1 , 4 do
                    for j = 1 , 4 do
                        -- surfaceTable[tostring(i) ..',' .. tostring(j)]:setNumXY( i, j, 1024)
                        surfaceTable[tostring(i) ..',' .. tostring(j)]:setNumXY( i, j, tempSurfaceTable[tostring(i) ..',' .. tostring(j)])
                        -- tempSurfaceTable[tostring(i) ..',' .. tostring(j)]
                    end
                end
                -- genRam(2)

                for i = 1 , 4 do
                    for j = 1 , 4 do
                        tempSurfaceTable[tostring(i) ..',' .. tostring(j)] = -1
                    end
                end

                longDisplay = true
                tableComMoving = true

                updateFreeSpace()

                genRam(2)
                -- keyPressDelayCouter = 20

            end            
        end
    end


end

function love.keypressed(k)
    -- exit keys
    if k == 'escape' then
        love.event.quit()
    end
    if love.keyboard.isDown('lgui') and love.keyboard.isDown('w') then
        love.event.quit()
    end

    if gameOver and k == 'return' then
        resetAll()
        genRam(2)
        genRam(2)
    end

    -- state change controled by keypress
    if state == 'non' and not gameOver then
        if love.keyboard.isDown('up') then
            moveCount = moveCount + 1
            state = 'up'
            upBar = true

            -- test --
            -- genRam(math.pow(2,math.random(1,11)))
            -- test end --

            numShift('up')
            tableComMoving = false
        elseif love.keyboard.isDown('left') then
            moveCount = moveCount + 1
            state = 'left'
            leftBar = true
            numShift('left')
            tableComMoving = false
        elseif love.keyboard.isDown('right') then
            moveCount = moveCount + 1
            state = 'right'
            rightBar = true
            numShift('right')
            tableComMoving = false
        elseif love.keyboard.isDown('down') then
            moveCount = moveCount + 1
            state = 'down'
            downBar = true
            numShift('down')
            tableComMoving = false
        end
    end
end

function love.draw()
    
    -- draw table
    drawTable()
    -- draw gray boxes
    drawGrayBox()
    -- print 4 edges of the controlling box 
    drawLine()
    -- print 4 conner with small circles
    drawConner()

    drawSurface()
    
    -- draw the box elements when elements complete moving in surface table 
    -- by mapping waiting list 
    drawTempSumedBox()

    -- draw temp surface table to see the contain , delete later
    drawTempSurfaceTable()

    love.graphics.setColor(1,1,1,1)
    love.graphics.print(freeSpace , 0 , 0 )
    love.graphics.print(moveCount , 0 , 20)
    -- local testTable = {2,2,2,2}




    if gameOver then
        toLight = true
        gameOverPage()
    end
    
    -- tempDraw()

end

function genRam(targetNum, targetX , targetY)
    targetNum = targetNum or 0
    targetX = targetX or -1
    targetY = targetY or -1

    math.randomseed(os.time())
    
    local x = 0
    local y = 0
    local xcy = '1,1'
    local val = 0
    if freeSpace == 0 then
        gameOver = true
    else -- free space > 0 

        if (targetX ~= -1) and (targetY ~= -1) then
            x = targetX
            y = targetY
            xcy = tostring(x)..','..tostring(y)
        else
            repeat
                x = math.random(4)
                y = math.random(4)
                xcy = tostring(x)..','..tostring(y)
            until (surfaceTable[xcy]:getNum() == 0)
        end
        
        if targetNum == 0 then
            if returnT (85) then
                val = 2
            else
                val = 4
            end
        else 
            val = targetNum
        end

        surfaceTable[xcy]:setNum(val)
        -- surfaceTable[xcy]:setRenderCondition()

        freeSpace = freeSpace -1
    end
end

-- consider how to control the grid
-- may be change by setting page
-- 1. by a controlling cube
-- 2. by holding left click then shift 4 dimentions(up down left right)
-- 3. by direction arrow key [DONE]


-- score + the sum 

--
    -- function genRamTable()
    --     for i = 1 , 16 do 
    --         genRam(math.pow(2,math.random(1,11)))
    --     end
    -- end 
--

function returnT(percent)
    -- math.randomseed(os.time())
    if math.random(math.pi*50*50+1)-1 < math.pi*50*50*percent/100 then
        return true
    else
        return false
    end
end

function resetAll()
    
    -- clear up the array and the hash table
    for i , box in pairs (surfaceTable) do
        box:setNum(0)
    end

    -- reset the variables
    freeSpace = 16
    moveCount = 0

 

    gameOver = false
end

function checkOver()
    if freeSpace == 0 then
        gameOver = true
    end
end

function xcyToNum(xcy)
    local x, y = xcy:match("([^,]+),([^,]+)")
    x,y = tonumber(x) , tonumber(y)
    return (4*y + x)
end

function checkComMoving()
    for i , box in pairs(surfaceTable) do
        if not box:getComMoving() then
            return false
        end
    end
    return true
end

function checkComRender()
    for i , box in pairs(tempRender) do
        if not box:getComRender() then
            return false
        end
    end
    return true
end

function updateFreeSpace()
    freeSpace = 16
    for i , box in pairs(surfaceTable) do
        if box:getNum() > 1 then
            freeSpace = freeSpace - 1
        end
    end
end
